package libMonkey

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
)

// InfoHash is the representation of an identifier in the MonkeyNet. As such,
// it is initialized once and does not change afterwards.
//
// An InfoHash is a 256bit data structure that is obtained by reading from a
// byte slice or by generating a new random InfoHash. It is intended to be
// generated by applying a hash function to a key in the distributed hash table.
type InfoHash [32]byte

// NewRandom generates an InfoHash through crypto/rand. If an error occurs
// during reading from the crypto/rand device, an empty InfoHash is returned
// with the error that reading from the crypto/rand device produced.
func NewRandom() (InfoHash, error) {
	var newling InfoHash
	b := make([]byte, 32)
	_, err := rand.Read(b)
	if err != nil {
		return newling, err
	}

	for i := range b {
		newling[i] = b[i]
	}
	return newling, nil
}

// Empty checks if an InfoHash was already initialised. If there are only
// bx00000000 bytes in the InfoHash, it is assumed uninitialised. An empty value
// therefore is an illegal identifier
func (i *InfoHash) Empty() bool {
	for it := range i {
		if i[it] != 0 {
			return false
		}
	}
	return true
}

// Write implements the io.Writer interface. If the InfoHash object is already
// initialised, 0 is returned with an error message.
//
// The InfoHash object is shifting bytes in from right to left, preserving the
// 0 prefix on the left.
func (i *InfoHash) Write(p []byte) (n int, err error) {
	if !i.Empty() {
		return 0, fmt.Errorf("%s is an already initialized value", i)
	}

	err = nil
	var it, ti int
	it = len(i)
	if len(i) < len(p) {
		n = len(i)
		ti = len(i)
	} else {
		n = len(p)
		ti = len(p)
	}
	for it > 0 && ti > 0 {
		i[it-1] = p[ti-1]
		it--
		ti--
	}

	return
}

// Xor is a function that xors two InfoHashes. This is needed for Kademlias XOR
// metric. The result is a new InfoHash
func (i InfoHash) Xor(another InfoHash) InfoHash {
	var hash InfoHash
	for b := range i {
		hash[b] = i[b] ^ another[b]
	}
	return hash
}

// CommonPrefixLenght compares to InfoHashes bitwise and finds the length of the
// bit-prefix both have in common.
func CommonPrefixLength(a, b InfoHash) int {
	var length, sum int
	fmt.Printf("%#v\n%#v\n\n", a, b)
	for length = 0; length < len(a); length++ {
		if a[length] != b[length] {
			bits := a[length] | b[length]
			var i uint = 1
			for i <= 8 {
				if (bits >> i) == 0 {
					sum += int(8 - i)
					break
				}
				i++
			}
			break
		} else {
			sum += 8
		}
	}
	return sum
}

// Implementation of the GoStringer interface
func (i InfoHash) GoString() string {
	return fmt.Sprintf("%#v", i[:])
}

// Implementation of the Stringer interface. All hashes are written as their
// base64-encoded content
func (i InfoHash) String() string {
	return base64.StdEncoding.EncodeToString(i[:])
}
